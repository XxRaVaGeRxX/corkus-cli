#include <fstream>
#include <string>
#include <map>
#include <filesystem>
#include <iostream>
#include <chrono>
#include <thread>

#include "../headers/main.h"
#include "../headers/config.h"
#include "../headers/options.h"
#include "../headers/quickmenu.h"
#include "../headers/audit.h"

using std::string;
using std::cout;
using std::filesystem::absolute;
using std::this_thread::sleep_for;


void showLoad() {
    for (int i = 0; i <= 100; i += 2) {
        cout << "\r </> Loading </>   " << i << "% " << std::flush;
        sleep_for(30ms);
    }
    cout << "✓✓ </> \n";
}

void showLoad2(const string &configFileName) {
    for (int i = 0; i <= 100; i += 2) {
        cout << "\r </> Checking Configs </>   " << i << "% " << std::flush;
        sleep_for(15ms);
    }
    cout << "✓✓ </> \n";
}

void genDefault() {
    const string configFile = ".cork";

    std::ofstream file(configFile);
    if (!file.is_open()) {
        std::cerr << " </> Error: Unable to create configuration file! </> \n";
        return;
    }
    sleep_for(500ms);

    file << R"(<?corkml version="0.1" encoding="UTF-8"?>
<CORKFILE>
<!--
     ██████╗ ██████╗ ██████╗ ██╗  ██╗██╗   ██╗███████╗
    ██╔════╝██╔═══██╗██╔══██╗██║ ██╔╝██║   ██║██╔════╝
    ██║     ██║   ██║██████╔╝█████╔╝ ██║   ██║███████╗
    ██║     ██║   ██║██╔══██╗██╔═██╗ ██║   ██║╚════██║
    ╚██████╗╚██████╔╝██║  ██║██║  ██╗╚██████╔╝███████║
     ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝ v2.0

     A RavagerStudio Official Project 2026 GPL 3.0

            || DEFAULT CONFIGURATION FILE ||

            Generated by Corkus automatically
 Manually generate and edit the un.cork for customization
       For more information visit the GitHub page
-->
    <corkml version="2.0" type="default">
        <config>
            <ModInfo>
                <Name>MyCoolMod</Name>
                <DisplayName>Cool Mod Name</DisplayName>
                <Description>My Cool Mod Project</Description>
                <Author>YourNameHere</Author>
                <Version>1.0.0</Version>
                <Website>https://your-website.com</Website>
            </ModInfo>
            <XML>
                <Skeletons>1,2,3,4,5,6</Skeletons>
                <Template>standard</Template>
                <OutputFile>ModInfo.xml</OutputFile>
            </XML>
            <Corkus>
                <WelcomeMessage>true</WelcomeMessage>
                <PauseAfterCompletion>false</PauseAfterCompletion>
                <AutoGenerateConfig>true</AutoGenerateConfig>
            </Corkus>
        </config>
        <KEY></KEY>
    </corkml>
</CORKFILE>
)";

    file.close();
    std::ifstream readFile(configFile);
    string content((std::istreambuf_iterator<char>(readFile)), std::istreambuf_iterator<char>());
    readFile.close();

    string secKey = generateKey(content);
    string encryptedSecKey = encryptKey(secKey);
    size_t keyPos = content.find("<KEY></KEY>");
    if (keyPos != string::npos) {
        content.replace(keyPos, 11, "<KEY>" + encryptedSecKey + "</KEY>");
    }

    std::ofstream writeFile(configFile);
    writeFile << content;
    writeFile.close();

    saveSecKey(configFile, secKey);
    cout << "\n </> FILENAME </> >> .cork << </> \n";
    cout << " </> PATH </>  " << absolute(".cork") << " </> " << std::endl;
}

bool genCustom() {
    const string configFile = "un.cork";

    if (std::filesystem::exists(configFile)) {
        cout << " </> !!User File Already Exists!! </> \n";
        if (userInput(" </> Overwrite the current un.cork? </> ")) {
            std::filesystem::remove(configFile);
            cout << " </>  Removed un.cork </> \n";
            cout << " </>  Start new un.cork generation </> \n\n";
        } else {
            cout << " </>  Skipping un.cork generation </> \n\n";
            cout << " </> Automated mod xml generation starting now </>";
            const Config config = loadConfig();
            const ModInfo mod = getInfoFromConfig(config);
            const string modName = mod.name;
            const string fileName = config.output_filename;
            createSFC(modName, config.xml_skeletons, config.xml_template_style);
            writeFile(modName, fileName, mod);
            cout << " </> Mod xml generation complete, Corkus Exiting </>";
            exit(0);
        }
    }

    std::ofstream file(configFile);
    if (!file.is_open()) {
        std::cerr << " </> Error: Unable to create configuration file! </> \n";
        return false;
    }


    showLoad();

    file << R"(<?corkml version="0.2" encoding="UTF-8"?>
<CORKFILE>
<!--
  ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸
         ██████╗ ██████╗ ██████╗ ██╗  ██╗██╗   ██╗███████╗ Corkus
        ██╔════╝██╔═══██╗██╔══██╗██║ ██╔╝██║   ██║██╔════╝
        ██║     ██║   ██║██████╔╝█████╔╝ ██║   ██║███████╗
        ██║     ██║   ██║██╔══██╗██╔═██╗ ██║   ██║╚════██║
        ╚██████╗╚██████╔╝██║  ██║██║  ██╗╚██████╔╝███████║
         ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝ v2.0
  ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸
         A RavagerStudio Official Project 2026 GPL 3.0
            ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸
                ██╗   ██╗███████╗███████╗██████╗  User
                ██║   ██║██╔════╝██╔════╝██╔══██╗
                ██║   ██║███████╗█████╗  ██████╔╝
                ██║   ██║╚════██║██╔══╝  ██╔══██╗
                ╚██████╔╝███████║███████╗██║  ██║
                 ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝
           ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸
            ||                                   ||
            ||  -|| USER CONFIGURATION FILE ||-  ||
            \/                                   \/
                             (^_^)
    ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸    |/ \|    ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸

             Generated by Corkus - auto-generates
                     a .cork for runtime
                anytime there is no file found.

                   - DO NOT ERASE THE KEY -
                Corkus verifies the file is an
      official .cork/un.cork config. Like a fingerprint.

          ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸

                    XML SKELETON REFERENCE:

                `°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`

          0  = ALL (Create all 24 skeletons at once)

          |1  = items              | 13 = loadingscreen
          |2  = blocks             | 14 = materials
          |3  = recipes            | 15 = particles
          |4  = buffs              | 16 = rwgmixer
          |5  = traders            | 17 = sounds
          |6  = item_modifiers     | 18 = spawning
          |7  = loot               | 19 = ui_display
          |8  = progression        | 20 = vehicle_properties
          |9  = entityclasses      | 21 = worldglobal
          |10 = entitygroups       | 22 = quests
          |11 = archetypes         | 23 = dialogs
          |12 = biomes             | 24 = npc

          Usage: Comma-separated (e.g., 1,3,7,15,22)

          ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸

                        TEMPLATE STYLES:

  ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸

    minimal       - Bare-bones, no comments (experienced modders)
    standard      - Balanced with common fields (recommended)
    comprehensive - Full documentation (learning/complex mods)

  ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ -->

    <corkml version="2.0" type="user">
        <config>
            <!-- ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ ModInfo ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ -->
            <ModInfo>
                <Name>MyCoolMod</Name>
                <DisplayName>Cool Mod Name</DisplayName>
                <Description>My Cool Mod Project</Description>
                <Author>YourNameHere</Author>
                <Version>1.0.0</Version>
                <Website>https://your-website.com</Website>
            </ModInfo>

            <!-- ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ XML Generation ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ -->
            <XML>
                <!-- Skeleton numbers: 0=all, or comma-separated 1-24 -->
                <Skeletons>1,2</Skeletons>
                <!-- Template: minimal, standard, or comprehensive -->
                <Template>standard</Template>
                <!-- Output filename for ModInfo -->
                <OutputFile>ModInfo.xml</OutputFile>
            </XML>

            <!-- ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ Corkus Behavior ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ -->
            <Corkus>
                <WelcomeMessage>true</WelcomeMessage>
                <PauseAfterCompletion>false</PauseAfterCompletion>
                <AutoGenerateConfig>true</AutoGenerateConfig>
            </Corkus>
        </config>
        <!-- ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ Fingerprint ¸,ø¤º°`°º¤ø¤º°`°º¤ø,¸ -->
        <KEY></KEY>
    </corkml>
</CORKFILE>
)";

    file.close();
    std::ifstream readFile(configFile);
    string content((std::istreambuf_iterator<char>(readFile)), std::istreambuf_iterator<char>());
    readFile.close();

    string secKey = generateKey(content);
    string encryptedSecKey = encryptKey(secKey);
    size_t keyPos = content.find("<KEY></KEY>");
    if (keyPos != string::npos) {
        content.replace(keyPos, 11, "<KEY>" + encryptedSecKey + "</KEY>");
    }

    std::ofstream writeFile(configFile);
    writeFile << content;
    writeFile.close();

    saveSecKey(configFile, secKey);
    cout << "\n </> FILENAME </> >> un.cork << </> \n";
    cout << " </> PATH </>  " << absolute("un.cork") << " </> " << std::endl;
    sleep_for(800ms);

    return true;
}


Config loadConfig() {
    showLoad2("configFileName");

    Config config;
    string configFile;

    if (std::filesystem::exists("un.cork")) {
        configFile = "un.cork";
        cout << "\n </> found un.cork file @" << absolute("un.cork") << " </> \n";
        cout << " </> Processing un.cork file </>";
        if (!verifyKey("un.cork")) {
            exit(99);
        }
        auto result = validate_cork_file("un.cork");

        if (!result.is_valid) {
            cout << "\n </> Verification Failed </> \n";
            for (const auto &error: result.errors) {
                cout << " - " << error << "\n";
            }
            exit(1);
        }
        string secKey = loadSecKeyFromFile("un.cork");
        cout << "\n </> Plain KEY= " + secKey + " </> \n";
        sleep_for(1s);
    } else if (std::filesystem::exists(".cork")) {
        configFile = ".cork";
        cout << "\n </> ### NO un.cork IN CURRENT DIRECTORY ### </> \n";
        cout << " </> Found .cork file @" << absolute(".cork") << " </> \n";
        cout << " </> Processing .cork file </>";
        if (!verifyKey(".cork")) {
            exit(99);
        }
        auto result = validate_cork_file(".cork");

        if (!result.is_valid) {
            cout << "\n </> Verification Failed </> \n";
            for (const auto &error: result.errors) {
                cout << " </> " << error << "\n";
            }
            exit(1);
        }
        string secKey = loadSecKeyFromFile(".cork");
        cout << "\n </> Plain KEY= " + secKey + " </> \n";
        sleep_for(1s);
    } else {
        cout << "\n </> A Corkus Configuration file of either type was not found </> \n";
        cout << " </> Generating default file now </> \n";

        genDefault();
        configFile = ".cork";
    }

    std::ifstream file(configFile);
    if (!file.is_open()) {
        cout << "\n </> Configuration file not found. </> \n";
        cout << " </> Generating default file... </> \n";
        genDefault();
        return config;
    }

    string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();

    auto getTagContent = [&content](const string &tagName) -> string {
        string openTag = "<" + tagName + ">";
        string closeTag = "</" + tagName + ">";
        size_t start = content.find(openTag);
        size_t end = content.find(closeTag);
        if (start != string::npos && end != string::npos) {
            start += openTag.length();
            return content.substr(start, end - start);
        }
        return "";
    };

    config.dName = getTagContent("Name");
    config.dDisName = getTagContent("DisplayName");
    config.dDesc = getTagContent("Description");
    config.dAuthor = getTagContent("Author");
    config.dVersion = getTagContent("Version");
    config.dWebsite = getTagContent("Website");

    config.xml_skeletons = getTagContent("Skeletons");
    config.xml_template_style = getTagContent("Template");
    config.output_filename = getTagContent("OutputFile");

    config.show_welcome_message = (getTagContent("WelcomeMessage") == "true");
    config.pause_after_completion = (getTagContent("PauseAfterCompletion") == "true");
    config.auto_generate_config = (getTagContent("AutoGenerateConfig") == "true");

    return config;
}
